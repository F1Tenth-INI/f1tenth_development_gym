from utilities.Settings import Settings
from utilities.state_utilities import *

import os.path
import numpy as np
import pandas as pd
import yaml

'''
HOW TO USE:

1. Generate/Get a Waypoints CSV File (https://github.com/TUMFTM/global_racetrajectory_optimization )
2. Set the MAP_WAYPOINT_FILE in Settings.py to the generated file (without .csv)
3. Set Waypoint parameters in config.yml
4. Use inside planner class like this:

# Import 
from utilities.waypoint_utils import WaypointUtils

# Initialize
waypoint_utils = WaypointUtils()

# Update at every step for the next_waypoints with the current car's position
car_position = [0., 0.]
waypoint_utils.update_next_waypoints(car_position)

# Access next waypoint's positions list([x,y]):
waypoints_positions = waypoint_utils.next_waypoint_positions

# Or Access next full waypoints list([dist, x, y, abs_angle, rel_angle, v_x, acc_x]):
waypoints = waypoint_utils.next_waypoints

'''
     
class WaypointUtils:
    
    def __init__(self, waypoint_file = None):
        config = yaml.load(open("config.yml", "r"), Loader=yaml.FullLoader)
        
        self.interpolation_steps = config['waypoints']['INTERPOLATION_STEPS']
        self.look_ahead_steps = self.interpolation_steps * config['waypoints']['LOOK_AHEAD_STEPS']
        
        # Waypoints generated by https://github.com/TUMFTM/global_racetrajectory_optimization   
        self.original_waypoints = WaypointUtils.load_waypoints(waypoint_file)
        
        # Full waypoints [t, x, y, abs_angle, rel_angle, vel_x, acc_x]
        self.waypoints = np.array(WaypointUtils.get_interpolated_waypoints(self.original_waypoints, self.interpolation_steps))
        # Waypoint positions [x, y]
        self.waypoint_positions = WaypointUtils.get_waypoint_positions(self.waypoints)
        
        self.nearest_waypoint_index = None
        self.next_waypoints = np.zeros((self.look_ahead_steps, 7), dtype=np.float32)
        self.next_waypoint_positions = np.zeros((self.look_ahead_steps,2), dtype=np.float32)
        
        
        
    def update_next_waypoints(self, car_position):
        if self.nearest_waypoint_index is None:
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position, self.waypoints)  # Run initial search of starting waypoint
        else:
            nearest_waypoint_index = self.nearest_waypoint_index + WaypointUtils.get_nearest_waypoint_index(car_position, self.next_waypoints)

        next_waypoints = []
        for j in range(self.look_ahead_steps):
            next_waypoint = self.waypoints[(nearest_waypoint_index + j) % len(self.waypoints)]
            next_waypoints.append(next_waypoint)
        next_waypoints = np.array(next_waypoints)
        
        self.next_waypoints = next_waypoints
        self.next_waypoint_positions = WaypointUtils.get_waypoint_positions(next_waypoints)
        self.nearest_waypoint_index = nearest_waypoint_index
        
    @staticmethod
    def load_waypoints(map_waypoint_file = None):
        
        path = Settings.MAP_WAYPOINT_FILE
        if map_waypoint_file is not None:
            path = map_waypoint_file

        file_path = path + '.csv'
        assert os.path.isfile(file_path), "Waypoint file (" + path+  ") does not exist"
        
        waypoints = pd.read_csv(file_path, header=None).to_numpy()
        return waypoints
    
    @staticmethod
    def get_interpolated_waypoints(waypoints, interpolation_steps):
        assert(interpolation_steps >= 1)
        waypoints_interpolated = []
        
        for j in range(len(waypoints) - 1):
            for i in range(interpolation_steps):
                interpolated_waypoint = waypoints[j] + (float(i)/interpolation_steps)*(waypoints[j+1]-waypoints[j])
                waypoints_interpolated.append(interpolated_waypoint)
        waypoints_interpolated.append(waypoints[-1])
        return waypoints_interpolated
    
    @staticmethod
    def get_nearest_waypoint_index(car_position, waypoints):

        min_dist = 10000
        min_dist_index = 0

        def squared_distance(p1, p2):
            squared_distance = abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2
            return squared_distance

        waypoint_positions = WaypointUtils.get_waypoint_positions(waypoints)
        for i in range(len(waypoint_positions)):
            dist = squared_distance(waypoint_positions[i], car_position)
            if (dist) < min_dist:
                min_dist = dist
                min_dist_index = i

        return min_dist_index
    
    @staticmethod
    def get_waypoint_positions(waypoints):
        return waypoints[:, 1:3]