from utilities.Settings import Settings
from utilities.state_utilities import *

import os.path
import numpy as np
import pandas as pd
import yaml

'''
HOW TO USE:

1. Generate/Get a Waypoints CSV File (https://github.com/TUMFTM/global_racetrajectory_optimization )
2. Set the waypoint_payth in the map config file (fe. config_Custom.yaml) to the generated file (without .csv)
3. Set Waypoint parameters in config.yml
4. Use inside planner class like this:

# Import 
from utilities.waypoint_utils import WaypointUtils

# Initialize
waypoint_utils = WaypointUtils()

# Update at every step for the next_waypoints with the current car's position
car_position = [0., 0.]
waypoint_utils.update_next_waypoints(car_position)

# Access next waypoint's positions list([x,y]):
waypoints_positions = waypoint_utils.next_waypoint_positions

# Or Access next full waypoints list([dist, x, y, abs_angle, rel_angle, v_x, acc_x]):
waypoints = waypoint_utils.next_waypoints

'''
     
class WaypointUtils:
    
    def __init__(self):
        config = yaml.load(open("config.yml", "r"), Loader=yaml.FullLoader)
        
        self.interpolation_steps = config['waypoints']['INTERPOLATION_STEPS']
        self.decrease_resolution_factor = config['waypoints']['DECREASE_RESOLUTION_FACTOR']

        self.look_ahead_steps = self.interpolation_steps * config['waypoints']['LOOK_AHEAD_STEPS']
        self.ignore_steps = config['waypoints']['IGNORE_STEPS']
        
        # Waypoints generated by https://github.com/TUMFTM/global_racetrajectory_optimization   
        self.original_waypoints = WaypointUtils.load_waypoints()
        
        # Full waypoints [traveled_dist, x, y, abs_angle, rel_angle, vel_x, acc_x]
        self.waypoints = WaypointUtils.get_interpolated_waypoints(self.original_waypoints, self.interpolation_steps) #increased resolution
        self.waypoints = WaypointUtils.get_decreased_resolution_wps(self.waypoints, self.decrease_resolution_factor) # decreased resolution
        self.waypoints = WaypointUtils.remove_duplicates(self.waypoints)

        # Waypoint positions [x, y]
        self.waypoint_positions = WaypointUtils.get_waypoint_positions(self.waypoints)
        
        self.trajectory_vectors, self.trajectory_norms, self.directions = self.get_vectors_between_waypoint_positions()
        self.nearest_waypoint_index = None
        
        # next waypoints including the ones ignored by index offset: Relevant for looking for next (cache for looking for next one)
        self.current_waypoint_cache = np.zeros((self.look_ahead_steps, 7), dtype=np.float32) 
        
         # next waypoints considering ignored waypoints index offset
        self.next_waypoints = np.zeros((self.look_ahead_steps, 7), dtype=np.float32)
        self.next_waypoint_positions = np.zeros((self.look_ahead_steps,2), dtype=np.float32)
        
        if(self.waypoints is None):
            self.current_waypoint_cache = np.array([])
            self.next_waypoints = np.array([])
            self.next_waypoint_positions = np.array([])
        
        
        
    def update_next_waypoints(self, car_position):
        if self.waypoints is None: return
        if self.nearest_waypoint_index is None:
            # Run initial search of starting waypoint (all waypoints)
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position, self.waypoints)  
        else: # only look for next waypoint in the current waypoint cache
            nearest_waypoint_index = self.nearest_waypoint_index + WaypointUtils.get_nearest_waypoint_index(car_position, self.current_waypoint_cache)

        next_waypoints_including_ignored = []
        for j in range(self.look_ahead_steps + self.ignore_steps):
            next_waypoint = self.waypoints[(nearest_waypoint_index + j) % len(self.waypoints)]
            next_waypoints_including_ignored.append(next_waypoint)
        next_waypoints_including_ignored = np.array(next_waypoints_including_ignored)
        
        self.next_waypoints = next_waypoints_including_ignored[self.ignore_steps:]
        self.current_waypoint_cache = next_waypoints_including_ignored
        
        self.next_waypoint_positions = WaypointUtils.get_waypoint_positions(self.next_waypoints)
        self.nearest_waypoint_index = nearest_waypoint_index
        
    @staticmethod
    def load_waypoints():
        
        map_config_file_path = Settings.MAP_CONFIG_FILE
        map_config = yaml.load(open(map_config_file_path, "r"), Loader=yaml.FullLoader)
        
        # Setting the waypoints in the mapfile is optional
        if("waypoint_path" not in map_config):
            # No waypoints at all
            print("No waypoints set.")
            return None

        path = map_config["waypoint_path"]
        file_path = path + '.csv'

        try: # Check if waypoint file exists
            assert os.path.isfile(file_path), "Waypoint file (" + path+  ") does not exist"
        except AssertionError:
            print("There are no waypoints at "+file_path)
            print("Continuting without waypoinnts")
            return None
        
        waypoints = pd.read_csv(file_path, header=None).to_numpy()
        return np.array(waypoints)
     
    @staticmethod
    def get_interpolated_waypoints(waypoints, interpolation_steps):
        if waypoints is None: return None
        assert(interpolation_steps >= 1)
        waypoints_interpolated = []
        
        for j in range(len(waypoints) - 1):
            for i in range(interpolation_steps):
                interpolated_waypoint = waypoints[j] + (float(i)/interpolation_steps)*(waypoints[j+1]-waypoints[j])
                waypoints_interpolated.append(interpolated_waypoint)
        waypoints_interpolated.append(waypoints[-1])
        return np.array(waypoints_interpolated)
    @staticmethod
    def get_decreased_resolution_wps(waypoints, decrease_resolution_factor):
        if waypoints is None: return None
        return np.array(waypoints[::decrease_resolution_factor])
    
    @staticmethod
    def get_nearest_waypoint_index(car_position, waypoints):

        min_dist = 10000
        min_dist_index = 0

        def squared_distance(p1, p2):
            squared_distance = abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2
            return squared_distance

        waypoint_positions = WaypointUtils.get_waypoint_positions(waypoints)
        for i in range(len(waypoint_positions)):
            dist = squared_distance(waypoint_positions[i], car_position)
            if (dist) < min_dist:
                min_dist = dist
                min_dist_index = i

        return min_dist_index
    
    @staticmethod
    def get_waypoint_positions(waypoints):
        if waypoints is None: return None
        return np.array(waypoints)[:, 1:3]
    
    def get_vectors_between_waypoint_positions(self):
        if self.waypoints is None: return None, None, None
        waypoint_positions = self.get_waypoint_positions(self.waypoints)
        vectors = []
        norms = []
        directions = []
        for i in range(len(waypoint_positions)-1):
            vector = waypoint_positions[i + 1] - waypoint_positions[i]
            vectors.append(vector)
            norm = np.linalg.norm(vector)
            norms.append(norm)
            directions.append(vector/norm)
        return vectors, norms, directions
    
    @staticmethod
    def remove_duplicates(waypoints):
        # Remove duplicate waypoints ( with same positions )
        if waypoints is None: return None
        
        wawypoint_positions = waypoints[:,1:3]
        unique_positions, unique_indices = np.unique(wawypoint_positions, axis=0, return_index=True)
        unique_indices = np.sort(unique_indices)
    
        unique_waypoints = waypoints[unique_indices, :]
        return np.array(unique_waypoints)
         