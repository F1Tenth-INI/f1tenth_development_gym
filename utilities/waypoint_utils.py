from utilities.Settings import Settings
from utilities.state_utilities import *

import os.path
import numpy as np
import pandas as pd
import yaml

'''
HOW TO USE:

1. Generate/Get a Waypoints CSV File (https://github.com/TUMFTM/global_racetrajectory_optimization )
2. Set the waypoint_payth in the map config file (fe. config_Custom.yaml) to the generated file (without .csv)
3. Set Waypoint parameters in config.yml
4. Use inside planner class like this:

# Import 
from utilities.waypoint_utils import WaypointUtils

# Initialize
waypoint_utils = WaypointUtils()

# Update at every step for the next_waypoints with the current car's position
car_position = [0., 0.]
waypoint_utils.update_next_waypoints(car_state)

# Access next waypoint's positions list([x,y]):
waypoints_positions = waypoint_utils.next_waypoint_positions

# Or Access next full waypoints list([dist, x, y, abs_angle, rel_angle, v_x, acc_x]):
waypoints = waypoint_utils.next_waypoints

'''


# Indices of waypoint
WP_S_IDX = 0 # Distance since start
WP_X_IDX = 1 # Position x
WP_Y_IDX = 2 # Position y
WP_PSI_IDX = 3 # Absolute angle of vector connecting to next wp
WP_KAPPA_IDX = 4 # Relative angle
WP_VX_IDX = 5 # Suggested velocity 
WP_A_X_IDX = 6 # Suggested acceleration


class WaypointUtils:
    
    def __init__(self, map_path = Settings.MAP_PATH, map_name = Settings.MAP_NAME):
        
        self.map_path = map_path
        self.map_name = map_name
        
        self.interpolation_steps = Settings.INTERPOLATION_STEPS
        self.decrease_resolution_factor = Settings.DECREASE_RESOLUTION_FACTOR

        self.look_ahead_steps = self.interpolation_steps * Settings.LOOK_AHEAD_STEPS
        self.ignore_steps = Settings.IGNORE_STEPS
        
        # Waypoints generated by https://github.com/TUMFTM/global_racetrajectory_optimization
        self.original_waypoints = self.load_waypoints()
        
        # Full waypoints [traveled_dist, x, y, abs_angle, rel_angle, vel_x, acc_x]
        self.waypoints, self.global_limit = self.correct_velocity(self.original_waypoints)
        self.waypoints = WaypointUtils.get_interpolated_waypoints(self.waypoints, self.interpolation_steps) #increased resolution
        self.waypoints = WaypointUtils.get_decreased_resolution_wps(self.waypoints, self.decrease_resolution_factor) # decreased resolution
        self.waypoints = WaypointUtils.remove_duplicates(self.waypoints)

        # Waypoint positions [x, y]
        self.waypoint_positions = WaypointUtils.get_waypoint_positions(self.waypoints)
        
        self.trajectory_vectors, self.trajectory_norms, self.directions = self.get_vectors_between_waypoint_positions()
        self.nearest_waypoint_index = None
        
        # next waypoints including the ones ignored by index offset: Relevant for looking for next (cache for looking for next one)
        self.current_waypoint_cache = np.zeros((self.look_ahead_steps, 7), dtype=np.float32) 
        
         # next waypoints considering ignored waypoints index offset
        self.next_waypoints = np.zeros((self.look_ahead_steps, 7), dtype=np.float32)
        self.next_waypoint_positions = np.zeros((self.look_ahead_steps,2), dtype=np.float32)
        self.next_waypoint_positions_relative = np.zeros((self.look_ahead_steps,2), dtype=np.float32)


        if(self.waypoints is None):
            self.current_waypoint_cache = np.array([])
            self.next_waypoints = np.array([])
            self.next_waypoint_positions = np.array([])
        
        
        
    def update_next_waypoints(self, car_state):
        if self.waypoints is None: return
    
        car_position = []
        # Main branch uses only car position for waypoints at the moment. 
        # TODO: Use full state everywhere
        if(len(car_state) == 2):
            car_position = car_state
            car_sin_theta = None
            car_cos_theta = None
        else:
            car_position = [car_state[POSE_X_IDX], car_state[POSE_Y_IDX]]
            car_sin_theta = car_state[POSE_THETA_SIN_IDX]
            car_cos_theta = car_state[POSE_THETA_COS_IDX]
        if self.nearest_waypoint_index is None:
            # Run initial search of starting waypoint (all waypoints)
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position, self.waypoints)  
        else: # only look for next waypoint in the current waypoint cache
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position,  self.waypoints)
            # nearest_waypoint_index = self.nearest_waypoint_index + WaypointUtils.get_nearest_waypoint_index(car_position, self.current_waypoint_cache)

        next_waypoints_including_ignored = []
        for j in range(self.look_ahead_steps + self.ignore_steps):
            next_waypoint = self.waypoints[(nearest_waypoint_index + j) % len(self.waypoints)]
            next_waypoints_including_ignored.append(next_waypoint)
        next_waypoints_including_ignored = np.array(next_waypoints_including_ignored)
        
        self.next_waypoints = next_waypoints_including_ignored[self.ignore_steps:]
        self.current_waypoint_cache = next_waypoints_including_ignored
        
        self.next_waypoint_positions = WaypointUtils.get_waypoint_positions(self.next_waypoints)
        self.next_waypoint_positions_relative = WaypointUtils.get_relative_positions(self.next_waypoints, car_state)
        self.nearest_waypoint_index = nearest_waypoint_index


    def load_waypoints(self):
        
        
        path = os.path.join(self.map_path, self.map_name+ "_wp")
        
        # exit()
             
        # Check if default wp are overwritten
        # map_config_file_path = Settings.MAP_CONFIG_FILE
        # map_config = yaml.load(open(map_config_file_path, "r"), Loader=yaml.FullLoader)
        # if("waypoint_path" in map_config):
        #     print("Overwriging default waypoint path by path defined in the Map.yaml file")
        #     path = map_config["waypoint_path"]


        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'

        file_path = path + '.csv'
        try: # Check if waypoint file exists
            assert os.path.isfile(file_path), "Waypoint file (" + path+  ") does not exist"
        except AssertionError:
            print("There are no waypoints at "+file_path)
            print("Continuting without waypoinnts")
            return None
        
        waypoints = pd.read_csv(file_path, header=1).to_numpy()
        return np.array(waypoints)
     
    @staticmethod
    def get_interpolated_waypoints(waypoints, interpolation_steps):
        if waypoints is None: return None
        assert(interpolation_steps >= 1)
        waypoints_interpolated = []
        
        for j in range(len(waypoints) - 1):
            for i in range(interpolation_steps):
                interpolated_waypoint = waypoints[j] + (float(i)/interpolation_steps)*(waypoints[j+1]-waypoints[j])
                waypoints_interpolated.append(interpolated_waypoint)
        waypoints_interpolated.append(waypoints[-1])
        return np.array(waypoints_interpolated)
    @staticmethod
    def get_decreased_resolution_wps(waypoints, decrease_resolution_factor):
        if waypoints is None: return None
        return np.array(waypoints[::decrease_resolution_factor])
    
    @staticmethod
    def get_nearest_waypoint_index(car_position, waypoints):

        min_dist = 10000
        min_dist_index = 0

        def squared_distance(p1, p2):
            squared_distance = abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2
            return squared_distance

        waypoint_positions = WaypointUtils.get_waypoint_positions(waypoints)
        for i in range(len(waypoint_positions)):
            dist = squared_distance(waypoint_positions[i], car_position)
            if (dist) < min_dist:
                min_dist = dist
                min_dist_index = i

        return min_dist_index
    
    @staticmethod
    def get_waypoint_positions(waypoints):
        if waypoints is None: return None
        return np.array(waypoints)[:, 1:3]
    
    def get_vectors_between_waypoint_positions(self):
        if self.waypoints is None: return None, None, None
        waypoint_positions = self.get_waypoint_positions(self.waypoints)
        vectors = []
        norms = []
        directions = []
        for i in range(len(waypoint_positions)-1):
            vector = waypoint_positions[i + 1] - waypoint_positions[i]
            vectors.append(vector)
            norm = np.linalg.norm(vector)
            norms.append(norm)
            directions.append(vector/norm)
        return vectors, norms, directions
    
    @staticmethod
    def remove_duplicates(waypoints):
        # Remove duplicate waypoints ( with same positions )
        if waypoints is None: return None
        
        wawypoint_positions = waypoints[:,1:3]
        unique_positions, unique_indices = np.unique(wawypoint_positions, axis=0, return_index=True)
        unique_indices = np.sort(unique_indices)
    
        unique_waypoints = waypoints[unique_indices, :]
        return np.array(unique_waypoints)
    
    @staticmethod
    def get_relative_positions(waypoints, car_state):
        waypoints_x_absolute = waypoints[:,WP_X_IDX]
        waypoints_y_absolute = waypoints[:,WP_Y_IDX]
     
        ### Coordinate transformation to describe waypoint position relative to car position, x-axis points through windshield, y-axis to the left of the driver            # Translation:
        # translation by x and y coordinate of car
        next_waypoints_x_after_translation = waypoints_x_absolute - car_state[POSE_X_IDX]
        next_waypoints_y_after_translation = waypoints_y_absolute - car_state[POSE_Y_IDX]

        # Rotation (counterclockwise):
        next_waypoints_x_relative = np.round( next_waypoints_x_after_translation * car_state[POSE_THETA_COS_IDX] + next_waypoints_y_after_translation *  car_state[POSE_THETA_SIN_IDX], 4)
        next_waypoints_y_relative = np.round( next_waypoints_x_after_translation * - car_state[POSE_THETA_SIN_IDX] + next_waypoints_y_after_translation *  car_state[POSE_THETA_COS_IDX], 4)

        next_waypoint_positions_relative = np.column_stack((next_waypoints_x_relative, next_waypoints_y_relative))
        return next_waypoint_positions_relative
    
    def correct_velocity(self, waypoints):
        map_name = Settings.MAP_NAME
        if Settings.REVERSE_DIRECTION:
            path_reverse = '_reverse'
        else:
            path_reverse  = ''
        global_limit = 1
        if Settings.APPLY_SPEED_SCALING_FROM_YAML:
            speed_scaling_pth = os.path.join(self.map_path,'speed_scaling'+path_reverse+'.yaml')

            if(not os.path.isfile(speed_scaling_pth)):
                # Create default speed scaling file
                print("No Speed scaling file defined. Creating new speed_scaling.yaml with default values")
                data = {
                    'global_limit' : 1.0,
                    'n_sectors' : 1,
                    'Sector0': {
                        'start': 0,
                        'end': len(waypoints)-1,
                        'scaling': 0.5
                        }
                    }

                with open( os.path.join(speed_scaling_pth), 'w') as file:
                    documents = yaml.dump(data, file)
                
            speed_scaling_config = yaml.load(open(speed_scaling_pth, "r"), Loader=yaml.FullLoader)
            
            speed_scaling_array = np.zeros(waypoints.shape[0]+2)
            
            warn = False
            
            global_limit = speed_scaling_config['global_limit']
            n_sectors = speed_scaling_config['n_sectors']
            for i in range(n_sectors):
                sector = speed_scaling_config['Sector'+str(i)]
                for j in range(sector['start'], sector['end']+1):
                    if(len(speed_scaling_array) > j):
                        speed_scaling_array[j] = sector['scaling']
                    else: warn = True

            if warn: print("warning: invalid speed scaling")
            # TODO: Interpolate at edges
            # TODO: Drop error when not all sectors are defined
            
            speed_scaling_array = np.array(speed_scaling_array[:-2])
            speed_scaling_array = np.clip(speed_scaling_array, 0, global_limit)
            waypoints[:,WP_VX_IDX ] = waypoints[:,WP_VX_IDX] * speed_scaling_array
        
        
        waypoints[:,WP_VX_IDX ] = waypoints[:,WP_VX_IDX] * Settings.GLOBAL_WAYPOINT_VEL_FACTOR
        return waypoints, global_limit

         