from utilities.Settings import Settings
from utilities.state_utilities import *

import csv
import os.path
import numpy as np
import pandas as pd
import yaml

'''
HOW TO USE:

1. Generate/Get a Waypoints CSV File (https://github.com/TUMFTM/global_racetrajectory_optimization )
2. Set the waypoint_payth in the map config file (fe. config_Custom.yaml) to the generated file (without .csv)
3. Set Waypoint parameters in config.yml
4. Use inside planner class like this:

# Import 
from utilities.waypoint_utils import WaypointUtils

# Initialize
waypoint_utils = WaypointUtils()

# Update at every step for the next_waypoints with the current car's position
car_position = [0., 0.]
waypoint_utils.update_next_waypoints(car_state)

# Access next waypoint's positions list([x,y]):
waypoints_positions = waypoint_utils.next_waypoint_positions

# Or Access next full waypoints list([dist, x, y, abs_angle, rel_angle, v_x, acc_x]):
waypoints = waypoint_utils.next_waypoints

'''


# Indices of waypoint
WP_S_IDX = 0 # Distance since start
WP_X_IDX = 1 # Position x
WP_Y_IDX = 2 # Position y
WP_PSI_IDX = 3 # Absolute angle of vector connecting to next wp
WP_KAPPA_IDX = 4 # Relative angle
WP_VX_IDX = 5 # Suggested velocity 
WP_A_X_IDX = 6 # Suggested acceleration
WP_GLOBID_IDX = 7


# Indices for sectors
SECTOR_START_IDX = 0
SECTOR_END_IDX = 1
SECTOR_SCALING_IDX = 2
SECTOR_LENGTH_IDX = 3


class WaypointUtils:
    
    def __init__(self,waypoint_file_name=Settings.MAP_NAME+"_wp", map_path= Settings.MAP_PATH , map_name=Settings.MAP_NAME ):
        
        self.map_path = map_path
        self.map_name = map_name
        self.waypoint_file_name = waypoint_file_name
        
        self.interpolation_steps = Settings.INTERPOLATION_STEPS
        self.decrease_resolution_factor = Settings.DECREASE_RESOLUTION_FACTOR

        self.look_ahead_steps = self.interpolation_steps * Settings.LOOK_AHEAD_STEPS
        self.ignore_steps = Settings.IGNORE_STEPS

        # sectors
        self.sector_index = 0
        self.sectors = None
        
        # Variables for automatic sector tuning
        self.sector_error_index = 0
        self.sector_number_of_states = 1
        self.sector_error = 0
        
        # Waypoints generated by https://github.com/TUMFTM/global_racetrajectory_optimization
        self.original_waypoints = self.load_waypoints()
        
        # Full waypoints [traveled_dist, x, y, abs_angle, rel_angle, vel_x, acc_x]
        self.waypoints, self.global_limit = self.correct_velocity(self.original_waypoints)
        self.waypoints = WaypointUtils.get_interpolated_waypoints(self.waypoints, self.interpolation_steps) #increased resolution
        self.waypoints = WaypointUtils.get_decreased_resolution_wps(self.waypoints, self.decrease_resolution_factor) # decreased resolution
        self.waypoints = WaypointUtils.remove_duplicates(self.waypoints)

        # Waypoint positions [x, y]
        self.waypoint_positions = WaypointUtils.get_waypoint_positions(self.waypoints)
        
        self.trajectory_vectors, self.trajectory_norms, self.directions = self.get_vectors_between_waypoint_positions()
        self.nearest_waypoint_index = None
        
        # next waypoints including the ones ignored by index offset: Relevant for looking for next (cache for looking for next one)
        self.current_waypoint_cache = np.zeros((self.look_ahead_steps, 8), dtype=np.float32) 
        
         # next waypoints considering ignored waypoints index offset
        self.next_waypoints = np.zeros((self.look_ahead_steps, 8), dtype=np.float32)
        self.next_waypoint_positions = np.zeros((self.look_ahead_steps,2), dtype=np.float32)
        self.next_waypoint_positions_relative = np.zeros((self.look_ahead_steps,2), dtype=np.float32)

 

        if(self.waypoints is None):
            self.current_waypoint_cache = np.array([])
            self.next_waypoints = np.array([])
            self.next_waypoint_positions = np.array([])
        
        
        
    def update_next_waypoints(self, car_state):
        if self.waypoints is None: return
        
        car_position = []
        # Main branch uses only car position for waypoints at the moment. 
        # TODO: Use full state everywhere
        if(len(car_state) == 2):
            car_position = car_state
            car_sin_theta = None
            car_cos_theta = None
        else:
            car_position = [car_state[POSE_X_IDX], car_state[POSE_Y_IDX]]
            car_sin_theta = car_state[POSE_THETA_SIN_IDX]
            car_cos_theta = car_state[POSE_THETA_COS_IDX]
        if self.nearest_waypoint_index is None:
            # Run initial search of starting waypoint (all waypoints)
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position, self.waypoints)  
        else: # only look for next waypoint in the current waypoint cache
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position,  self.waypoints)
            # nearest_waypoint_index = self.nearest_waypoint_index + WaypointUtils.get_nearest_waypoint_index(car_position, self.current_waypoint_cache)

        # Find out in which sector the car is
        if(self.sectors is not None):
            for i in range(self.sectors.shape[0]):
                if self.sectors[i, SECTOR_START_IDX] <= nearest_waypoint_index * self.decrease_resolution_factor < self.sectors[i, SECTOR_END_IDX]:
                    self.sector_index = i  
                    break
        
        if(Settings.AUTOMATIC_SECTOR_TUNING):
            self.automatic_sector_tuning(nearest_waypoint_index, car_state)
        
        next_waypoints_including_ignored = []
        next_waypoints_indices_including_ignored = []
        for j in range(self.look_ahead_steps + self.ignore_steps):
            next_waypoint_idx = (nearest_waypoint_index + j) % len(self.waypoints)
            next_waypoint = self.waypoints[next_waypoint_idx]
            next_waypoints_indices_including_ignored.append(next_waypoint_idx)
            next_waypoints_including_ignored.append(next_waypoint)
        next_waypoints_including_ignored = np.array(next_waypoints_including_ignored)
        next_waypoints_indices_including_ignored = np.array(next_waypoints_indices_including_ignored)
        
        self.next_waypoints[..., :-1] = next_waypoints_including_ignored[self.ignore_steps:]
        self.next_waypoints[..., -1] = next_waypoints_indices_including_ignored[self.ignore_steps:]
        self.current_waypoint_cache = next_waypoints_including_ignored
        
        self.next_waypoint_positions = WaypointUtils.get_waypoint_positions(self.next_waypoints)
        self.next_waypoint_positions_relative[...] = WaypointUtils.get_relative_positions(self.next_waypoints, car_state)
        self.nearest_waypoint_index = nearest_waypoint_index

    def automatic_sector_tuning(self, nearest_waypoint_index, car_state):
        if self.sector_error_index == self.sector_index:
            nearest_waypoint_position = self.waypoints[nearest_waypoint_index][WP_X_IDX:WP_Y_IDX+1]
            car_position = [car_state[POSE_X_IDX], car_state[POSE_Y_IDX]]
            dist = np.linalg.norm(nearest_waypoint_position - car_position)
            self.sector_error += dist
            self.sector_number_of_states +=1
        else: # new sector
            # Normalize sector error
            self.sector_error = self.sector_error / self.sector_number_of_states 
            print("sector error", self.sector_error)
            print("New sector", self.sector_index)
            
        
            sector = self.sectors[self.sector_error_index]
            error_shifted = self.sector_error - 0.20
            sector[SECTOR_SCALING_IDX] -= 1.5*error_shifted
            print("Adusting sector scaling by ", 1.5 * -error_shifted)
            
            
            # Read the file into a list of lines
            with open(self.speed_scaling_pth, 'r') as file:
                lines = file.readlines()

            # Replace the ith line
            csv_line = str(sector[SECTOR_START_IDX]) + ","+ str(sector[SECTOR_SCALING_IDX]) + "\n"
            lines[self.sector_error_index + 1] = csv_line # +1 because of header

            # Write the list of lines back to the file
            with open(self.speed_scaling_pth, 'w') as file:
                file.writelines(lines)
            # Load the CSV file
            # df = pd.read_csv(self.speed_scaling_pth, header=1)
            # df.loc[self.sector_index -1] = csv_line
            # df.to_csv(self.speed_scaling_pth, index=False)

            
            self.sector_error = 0
            self.sector_number_of_states = 0
            self.sector_error_index = self.sector_index
            
            self.reload_waypoints()

    def reload_waypoints(self):
        self.original_waypoints = self.load_waypoints()
        
        # Full waypoints [traveled_dist, x, y, abs_angle, rel_angle, vel_x, acc_x]
        self.waypoints, self.global_limit = self.correct_velocity(self.original_waypoints)
        self.waypoints = WaypointUtils.get_interpolated_waypoints(self.waypoints, self.interpolation_steps) #increased resolution
        self.waypoints = WaypointUtils.get_decreased_resolution_wps(self.waypoints, self.decrease_resolution_factor) # decreased resolution
        self.waypoints = WaypointUtils.remove_duplicates(self.waypoints)

        # Waypoint positions [x, y]
        self.waypoint_positions = WaypointUtils.get_waypoint_positions(self.waypoints)
        
        
    def load_waypoints(self):
        
        
        path = os.path.join(self.map_path, self.waypoint_file_name)
        
        
        
        # exit()
             
        # Check if default wp are overwritten
        # map_config_file_path = Settings.MAP_CONFIG_FILE
        # map_config = yaml.load(open(map_config_file_path, "r"), Loader=yaml.FullLoader)
        # if("waypoint_path" in map_config):
        #     print("Overwriging default waypoint path by path defined in the Map.yaml file")
        #     path = map_config["waypoint_path"]


        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'

        file_path = path + '.csv'
        try: # Check if waypoint file exists
            assert os.path.isfile(file_path), "Waypoint file (" + path+  ") does not exist"
        except AssertionError:
            print("There are no waypoints at "+file_path)
            print("Continuting without waypoinnts")
            return None
        
        waypoints = pd.read_csv(file_path, header=1, comment='#').to_numpy()
        
        # Original Psi is the normal angle but we want the translational one
        waypoints[:, WP_PSI_IDX] += 0.5 * np.pi
        return np.array(waypoints)
     
    @staticmethod
    def get_interpolated_waypoints(waypoints, interpolation_steps):
        if waypoints is None: return None
        assert(interpolation_steps >= 1)
        waypoints_interpolated = []
        
        for j in range(len(waypoints) - 1):
            for i in range(interpolation_steps):
                interpolated_waypoint = waypoints[j] + (float(i)/interpolation_steps)*(waypoints[j+1]-waypoints[j])
                waypoints_interpolated.append(interpolated_waypoint)
        waypoints_interpolated.append(waypoints[-1])
        return np.array(waypoints_interpolated)
    @staticmethod
    def get_decreased_resolution_wps(waypoints, decrease_resolution_factor):
        if waypoints is None: return None
        return np.array(waypoints[::decrease_resolution_factor])
    
    @staticmethod
    def get_nearest_waypoint_index(car_position, waypoints):

        min_dist = 10000
        min_dist_index = 0

        def squared_distance(p1, p2):
            squared_distance = abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2
            return squared_distance

        waypoint_positions = WaypointUtils.get_waypoint_positions(waypoints)
        for i in range(len(waypoint_positions)):
            dist = squared_distance(waypoint_positions[i], car_position)
            if (dist) < min_dist:
                min_dist = dist
                min_dist_index = i

        return min_dist_index
    
    @staticmethod
    def get_waypoint_positions(waypoints):
        if waypoints is None: return None
        return np.array(waypoints)[:, 1:3]
    
    def get_vectors_between_waypoint_positions(self):
        if self.waypoints is None: return None, None, None
        waypoint_positions = self.get_waypoint_positions(self.waypoints)
        vectors = []
        norms = []
        directions = []
        for i in range(len(waypoint_positions)-1):
            vector = waypoint_positions[i + 1] - waypoint_positions[i]
            vectors.append(vector)
            norm = np.linalg.norm(vector)
            norms.append(norm)
            directions.append(vector/norm)
        return vectors, norms, directions
    
    @staticmethod
    def remove_duplicates(waypoints):
        # Remove duplicate waypoints ( with same positions )
        if waypoints is None: return None
        
        wawypoint_positions = waypoints[:,1:3]
        unique_positions, unique_indices = np.unique(wawypoint_positions, axis=0, return_index=True)
        unique_indices = np.sort(unique_indices)
    
        unique_waypoints = waypoints[unique_indices, :]
        return np.array(unique_waypoints)
    
    @staticmethod
    def get_relative_positions(waypoints, car_state):
        waypoints_x_absolute = waypoints[:,WP_X_IDX]
        waypoints_y_absolute = waypoints[:,WP_Y_IDX]
     
        ### Coordinate transformation to describe waypoint position relative to car position, x-axis points through windshield, y-axis to the left of the driver            # Translation:
        # translation by x and y coordinate of car
        next_waypoints_x_after_translation = waypoints_x_absolute - car_state[POSE_X_IDX]
        next_waypoints_y_after_translation = waypoints_y_absolute - car_state[POSE_Y_IDX]

        # Rotation (counterclockwise):
        next_waypoints_x_relative = np.round( next_waypoints_x_after_translation * car_state[POSE_THETA_COS_IDX] + next_waypoints_y_after_translation *  car_state[POSE_THETA_SIN_IDX], 4)
        next_waypoints_y_relative = np.round( next_waypoints_x_after_translation * - car_state[POSE_THETA_SIN_IDX] + next_waypoints_y_after_translation *  car_state[POSE_THETA_COS_IDX], 4)

        next_waypoint_positions_relative = np.column_stack((next_waypoints_x_relative, next_waypoints_y_relative))
        return next_waypoint_positions_relative
    
    def correct_velocity(self, waypoints):
        correct_velocity(waypoints, Settings)
        return waypoints, Settings.GLOBAL_SPEED_LIMIT


# Utility functions
def get_path_suffix(reverse_direction):
    return '_reverse' if reverse_direction else ''


def create_default_speed_scaling_file(speed_scaling_pth):
    print("No Speed scaling file defined. Creating new speed_scaling.csv with default values")
    with open(speed_scaling_pth, 'w') as f:
        f.write('#start,scaling\n')
        f.write('0,0.5\n')


def create_sectors(speed_scaling_csv, waypoints_len):
    sectors = []
    for i, csv_line in enumerate(speed_scaling_csv):
        start = int(csv_line[0])
        end = (int(waypoints_len) - 1) if (i == speed_scaling_csv.shape[0] - 1) else (int(speed_scaling_csv[i + 1, 0]) - 1)
        length = (end - start) + 1
        sector = [start, end, csv_line[1], length]
        sectors.append(sector)
    return np.array(sectors)


def generate_speed_scaling_array(sectors):
    speed_scaling_array = []

    for sector in sectors:
        length = int(sector[SECTOR_LENGTH_IDX])
        scaling_value = sector[SECTOR_SCALING_IDX]
        repeated_values = np.full(length, scaling_value)
        speed_scaling_array.append(repeated_values)

    speed_scaling_array = np.concatenate(speed_scaling_array)

    return speed_scaling_array


def get_speed_scaling_from_sectors(waypoints_len, settings):
    # TODO: Interpolate at edges
    # TODO: Drop error when not all sectors are defined
    path_reverse = get_path_suffix(settings.REVERSE_DIRECTION)

    speed_scaling_pth = os.path.join(settings.map_path, f"{settings.MAP_NAME}_speed_scaling{path_reverse}.csv")

    if not os.path.isfile(speed_scaling_pth):
        create_default_speed_scaling_file(speed_scaling_pth)

    speed_scaling_csv = pd.read_csv(speed_scaling_pth, comment='#', header=None).to_numpy()
    sectors = create_sectors(speed_scaling_csv, waypoints_len)

    speed_scaling_array = generate_speed_scaling_array(sectors)

    return speed_scaling_array


def get_speed_scaling(waypoints_len, settings):
    speed_scaling = settings.GLOBAL_WAYPOINT_VEL_FACTOR
    if settings.APPLY_SPEED_SCALING_FROM_CSV:
        speed_scaling *= get_speed_scaling_from_sectors(waypoints_len, settings)
    speed_scaling = np.clip(speed_scaling, 0, settings.GLOBAL_SPEED_LIMIT)
    return speed_scaling


def correct_velocity(waypoints, settings):
    speed_scaling = get_speed_scaling(waypoints.shape[0], settings)
    waypoints[:, WP_VX_IDX] *= speed_scaling
    return waypoints


         