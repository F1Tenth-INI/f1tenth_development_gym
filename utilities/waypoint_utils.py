from utilities.Settings import Settings
from utilities.state_utilities import *

import time
import threading

import os.path
import numpy as np
import pandas as pd

from numba import njit, prange
from numba.np.extensions import cross2d

'''
HOW TO USE:

1. Generate/Get a Waypoints CSV File (https://github.com/TUMFTM/global_racetrajectory_optimization )
2. Set the waypoint_payth in the map config file (fe. config_Custom.yaml) to the generated file (without .csv)
3. Set Waypoint parameters in config.yml
4. Use inside planner class like this:

# Import 
from utilities.waypoint_utils import WaypointUtils

# Initialize
waypoint_utils = WaypointUtils()

# Update at every step for the next_waypoints with the current car's position
car_position = [0., 0.]
waypoint_utils.update_next_waypoints(car_state)

# Access next waypoint's positions list([x,y]):
waypoints_positions = waypoint_utils.next_waypoint_positions

# Or Access next full waypoints list([dist, x, y, abs_angle, rel_angle, v_x, acc_x]):
waypoints = waypoint_utils.next_waypoints

'''


# Indices of waypoint
WP_S_IDX = 0 # Distance since start
WP_X_IDX = 1 # Position x
WP_Y_IDX = 2 # Position y
WP_PSI_IDX = 3 # Absolute angle of vector connecting to next wp
WP_KAPPA_IDX = 4 # Relative angle
WP_VX_IDX = 5 # Suggested velocity 
WP_A_X_IDX = 6 # Suggested acceleration
WP_GLOBID_IDX = 7


# Indices for sectors
SECTOR_START_IDX = 0
SECTOR_END_IDX = 1
SECTOR_SCALING_IDX = 2
SECTOR_LENGTH_IDX = 3



class WaypointUtils:
    
    def __init__(self,waypoint_file_name=Settings.MAP_NAME+"_wp", map_path= Settings.MAP_PATH , map_name=Settings.MAP_NAME, speed_scaling_file_name=Settings.MAP_NAME+"_speed_scaling.csv"):
        
        self.map_path = map_path
        self.map_name = map_name
        self.waypoint_file_name = waypoint_file_name
        self.speed_scaling_file_name = speed_scaling_file_name
        
        self.interpolation_steps = Settings.INTERPOLATION_STEPS
        self.decrease_resolution_factor = Settings.DECREASE_RESOLUTION_FACTOR

        self.look_ahead_steps = self.interpolation_steps * Settings.LOOK_AHEAD_STEPS
        self.ignore_steps = Settings.IGNORE_STEPS

        self.car_state = None

        # sectors
        self.sector_index = 0
        self.sector_scaling = 0
        self.sectors = None
        
        # Waypoints generated by https://github.com/TUMFTM/global_racetrajectory_optimization
        self.original_waypoints = self.load_waypoints()
        self.sectors = self.load_sectors()

        # print(self.sectors)
        # exit()
        
        self.current_distance_to_raceline = 0

        self.global_limit = None
        self.waypoints = None  # type: Optional[np.ndarray]
        self.waypoint_positions = None

        self.preprocess_waypoints()

        self.nearest_waypoint_index = None
        self.lap_count = 0
        self.cumulative_progress = 0
        self.initial_position = None
        self.previous_distance = 0
        self.initial_distance = None

         # next waypoints considering ignored waypoints index offset
        self.next_waypoints = np.zeros((self.look_ahead_steps, 8), dtype=np.float32)
        self.next_waypoint_positions = np.zeros((self.look_ahead_steps,2), dtype=np.float32)
        self.next_waypoint_positions_relative = np.zeros((self.look_ahead_steps,2), dtype=np.float32)

        self.obstacle_on_raceline = False
        self.obstacle_position = None

        if self.waypoints is None:
            self.next_waypoints = np.array([])
            self.next_waypoint_positions = np.array([])
            
        #Precompile jit functions
        dummy_car_state = np.zeros(NUMBER_OF_STATES)
        dummy_lidar_points = np.zeros((40, 2))
        get_relative_positions_jit(self.next_waypoints, dummy_car_state)
        get_nearest_waypoint(dummy_car_state, self.waypoints)
        squared_distance([0,0], [1,1])
        check_if_obstacle_on_raceline(dummy_lidar_points, self.next_waypoint_positions)
        
        # Start the thread that reloads waypoints every 5 seconds
        self.start_reload_waypoints_thread()

    def start_reload_waypoints_thread(self):
        if Settings.OPTIMIZE_FOR_RL: # If we are optimizing for RL, we don't need to reload waypoints
            self.reload_waypoints()
            return
        else:
            def reload_loop(): # Reload waypoints every 5 seconds
                while True:
                    self.reload_waypoints()
                    time.sleep(5)
            thread = threading.Thread(target=reload_loop)
            thread.daemon = True  # Daemonize thread to exit when main program exits
            thread.start()
            
    def update_next_waypoints(self, car_state):
        waypoints = self.waypoints
        if waypoints is None:
            return

        search_threshold_squared = Settings.GLOBAL_WAYPOINTS_SEARCH_THRESHOLD**2

        (
            nearest_waypoint_index,
            next_waypoints,
            sector_index,
            sector_scaling,
        ) = jit_update_next_waypoints(
            car_state,
            waypoints,
            self.nearest_waypoint_index,
            self.ignore_steps,
            self.look_ahead_steps,
            self.decrease_resolution_factor,
            self.sectors,
            search_threshold_squared,  
        )

        self.car_state = car_state
        self.next_waypoints[...] = next_waypoints
        self.next_waypoint_positions[...] = get_waypoint_positions(next_waypoints)
        self.next_waypoint_positions_relative[...] = get_relative_positions_jit(next_waypoints, car_state)
        self.nearest_waypoint_index = nearest_waypoint_index

        if sector_index is not None:
            self.sector_index = sector_index
        if sector_scaling is not None:
            self.sector_scaling = sector_scaling
        
        self.update_distance_to_raceline()

    def update_distance_to_raceline(self):
        
        car_position = np.array([self.car_state[POSE_X_IDX], self.car_state[POSE_Y_IDX]])
        self.current_distance_to_last, self.current_distance_to_next, self.current_distance_to_raceline = get_distance_to_raceline_jit(
            self.waypoints, self.nearest_waypoint_index, car_position
        )
    

    def preprocess_waypoints(self):

        original_waypoints = self.original_waypoints

        # Full waypoints [traveled_dist, x, y, abs_angle, rel_angle, vel_x, acc_x]
        waypoints, self.global_limit = self.correct_velocity(original_waypoints)
        waypoints = WaypointUtils.get_interpolated_waypoints(waypoints, self.interpolation_steps)  # increased resolution
        waypoints = WaypointUtils.get_decreased_resolution_wps(waypoints, self.decrease_resolution_factor)  # decreased resolution
        waypoints = WaypointUtils.remove_duplicates(waypoints)

        # Waypoint positions [x, y]
        waypoint_positions = get_waypoint_positions(waypoints)

        self.waypoints = waypoints
        self.waypoint_positions = waypoint_positions

        # This last line seems to be not used anywhere, for a long time
        # self.trajectory_vectors, self.trajectory_norms, self.directions = self.get_vectors_between_waypoint_positions()

    def reload_waypoints(self):

        waypoint_file_name = self.waypoint_file_name
        self.original_waypoints = self.load_waypoints(waypoint_file_name)
        self.sectors = self.load_sectors()
        self.preprocess_waypoints()
        
    def load_waypoints(self, waypoint_file_name=None):

        if waypoint_file_name is None:
            waypoint_file_name = self.waypoint_file_name

        path = os.path.join(self.map_path, waypoint_file_name)

        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'

        file_path = path + '.csv'
        try: # Check if waypoint file exists
            assert os.path.isfile(file_path), "Waypoint file (" + path+  ") does not exist"
        except AssertionError:
            print("There are no waypoints at "+file_path)
            print("Continuting without waypoinnts")
            return None
        
        waypoints = pd.read_csv(file_path, comment='#')
        waypoints.loc[:, "idx_global"] = np.arange(waypoints.shape[0])
        waypoints = waypoints.to_numpy()
        # Original Psi is the normal angle but we want the translational one
        waypoints[:, WP_PSI_IDX] += 0.5 * np.pi
        return np.array(waypoints)
    
    def load_sectors(self):
        speed_scaling_file = os.path.join(self.map_path, self.speed_scaling_file_name)


        if Settings.REVERSE_DIRECTION:
            speed_scaling_file = speed_scaling_file + '_reverse'
        
        if not os.path.exists(speed_scaling_file):
            create_default_speed_scaling_file(speed_scaling_file)


        sector_csv = pd.read_csv(speed_scaling_file, comment='#', header=None).to_numpy()
        result = []
        for i in range(len(sector_csv)):
            start_idx = int(sector_csv[i][0])
            scaling = sector_csv[i][1]
            if i < len(sector_csv) - 1:
                end_idx = int(sector_csv[i + 1][0]) - 1
            else:
                end_idx = len(self.original_waypoints)-1  # Use the index of the last waypoint
            length_of_sector = end_idx - start_idx
            result.append([start_idx, end_idx, scaling, length_of_sector])
        return np.array(result)


    def add_sector(self):
        current_sector = self.sectors[self.sector_index]
        new_sector = np.zeros(4)
        new_sector[SECTOR_START_IDX] = self.next_waypoints[0, WP_GLOBID_IDX]
        new_sector[SECTOR_SCALING_IDX] = self.sector_scaling
        new_sector[SECTOR_END_IDX] = current_sector[SECTOR_END_IDX]

        current_sector[SECTOR_END_IDX] = new_sector[SECTOR_START_IDX] - 1

        self.sectors[self.sector_index] = current_sector
        self.sectors = np.insert(self.sectors, self.sector_index + 1, new_sector, axis=0)

        self.sectors = self.sectors[self.sectors[:, SECTOR_START_IDX].argsort()]
        self.save_sector_file()


    def delete_current_sector(self):

        if len(self.sectors) > 1:
            # Remove the current sector
            self.sectors = np.delete(self.sectors, self.sector_index, axis=0)
            # Adjust the sector index if necessary
            if self.sector_index >= len(self.sectors):
                self.sector_index = len(self.sectors) - 1
        self.save_sector_file()

    def change_sector(self, sector_index, new_scaling):
        self.sectors[sector_index][SECTOR_SCALING_IDX] = new_scaling
        self.save_sector_file()

    def save_sector_file(self):
        path = os.path.join(self.map_path, self.map_name)
        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'
        speed_scaling_pth = path + '_speed_scaling.csv'
        with open(speed_scaling_pth, 'w') as f:
            f.write('#Start,Scaling\n')
            for i in range(len(self.sectors)):
                f.write(str(self.sectors[i][SECTOR_START_IDX]) + ',' + str(self.sectors[i][SECTOR_SCALING_IDX]) + '\n')

        self.reload_waypoints()

    @staticmethod
    def get_interpolated_waypoints(waypoints, interpolation_steps):
        if waypoints is None: return None
        assert(interpolation_steps >= 1)
        waypoints_interpolated = []
        
        for j in range(len(waypoints) - 1):
            for i in range(interpolation_steps):
                interpolated_waypoint = waypoints[j] + (float(i)/interpolation_steps)*(waypoints[j+1]-waypoints[j])
                waypoints_interpolated.append(interpolated_waypoint)
        waypoints_interpolated.append(waypoints[-1])
        return np.array(waypoints_interpolated)

    @staticmethod
    def get_decreased_resolution_wps(waypoints, decrease_resolution_factor):
        if waypoints is None: return None
        return np.array(waypoints[::decrease_resolution_factor])

    
    # Seems unused
    def get_vectors_between_waypoint_positions(self):
        if self.waypoints is None: return None, None, None
        waypoint_positions = self.get_waypoint_positions(self.waypoints)
        vectors = []
        norms = []
        directions = []
        for i in range(len(waypoint_positions)-1):
            vector = waypoint_positions[i + 1] - waypoint_positions[i]
            vectors.append(vector)
            norm = np.linalg.norm(vector)
            norms.append(norm)
            directions.append(vector/norm)
        return vectors, norms, directions
    
    @staticmethod
    def remove_duplicates(waypoints):
        # Remove duplicate waypoints ( with same positions )
        if waypoints is None: return None
        
        wawypoint_positions = waypoints[:,1:3]
        unique_positions, unique_indices = np.unique(wawypoint_positions, axis=0, return_index=True)
        unique_indices = np.sort(unique_indices)
    
        unique_waypoints = waypoints[unique_indices, :]
        return np.array(unique_waypoints)
    

    
    def correct_velocity(self, waypoints):
        settings = Settings        
        speed_scaling = get_speed_scaling(waypoints.shape[0], self.map_path, self.map_name, settings)
        waypoints[:, WP_VX_IDX] *= speed_scaling
        return waypoints, Settings.GLOBAL_SPEED_LIMIT

    def check_if_obstacle_on_my_raceline(self, lidar_points):
        if Settings.SLOW_DOWN_IF_OBSTACLE_ON_RACELINE or Settings.ALLOW_ALTERNATIVE_RACELINE:
            self.obstacle_on_raceline, self.obstacle_position = check_if_obstacle_on_raceline(lidar_points, self.next_waypoint_positions)
            self.scale_down_velocity_for_trailing_obstacle(self.obstacle_position)

    def scale_down_velocity_for_trailing_obstacle(self, obstacle_position):
        if Settings.SLOW_DOWN_IF_OBSTACLE_ON_RACELINE:
            if self.obstacle_on_raceline:
                distance_to_obstacle = np.linalg.norm(self.next_waypoint_positions - obstacle_position, axis=1)
                scaling_factor = np.clip(distance_to_obstacle / 5, 0.1, 1)
                self.next_waypoints[:, WP_VX_IDX] *= scaling_factor
                
    def get_cumulative_lap_progress(self):
        total_distance = self.waypoints[-1][WP_S_IDX]  # Full track length
        current_distance = self.waypoints[self.nearest_waypoint_index][WP_S_IDX]

        # Initialize progress tracking
        if self.initial_position is None:
            self.initial_position = current_distance  # Store starting position
            self.cumulative_progress = 0.0  # Start cumulative progress at 0
            self.previous_distance = current_distance
            self.lap_count = 0
            return 0.0

        # Compute movement since last step
        delta_distance = current_distance - self.previous_distance

        # Handle wraparound at start/finish line (correct sign of delta)
        if delta_distance < -0.5 * total_distance:
            delta_distance += total_distance  # Fix for crossing from last to first waypoint
        elif delta_distance > 0.5 * total_distance:
            delta_distance -= total_distance  # Fix for crossing from first to last waypoint

        # Update cumulative progress (keeps accumulating beyond 1.0 and below 0.0)
        self.cumulative_progress += delta_distance / total_distance

        # **Lap Increment (Crossing Initial Position Forward)**
        if self.previous_distance > self.initial_position and current_distance < self.initial_position:
            self.lap_count += 1
            print(f"Lap completed! Total laps: {self.lap_count}")

        # **Lap Decrement (Crossing Initial Position Backward)**
        if self.previous_distance < self.initial_position and current_distance > self.initial_position:
            self.lap_count -= 1
            print(f"Lap decremented! Total laps: {self.lap_count}")

        #  Store previous position for next step
        self.previous_distance = current_distance  

        return self.cumulative_progress

    @staticmethod
    def get_relative_positions(waypoints, car_state):
        return get_relative_positions_jit(waypoints, car_state)

# Move computationally heavy operations outside of class for jit compilation
@njit(fastmath=True)
def jit_update_next_waypoints(
    car_state,
    waypoints,
    last_nearest_waypoint_index,
    ignore_steps,
    look_ahead_steps,
    decrease_resolution_factor,
    sectors,
    search_threshold_squared,  # Pass from Settings
):
    num_waypoints = len(waypoints)

    # Find nearest waypoint
    if last_nearest_waypoint_index is None:
        nearest_waypoint_index, nearest_waypoint_dist = get_nearest_waypoint(car_state, waypoints)
    else:
        nearest_waypoint_index, nearest_waypoint_dist = get_nearest_waypoint(
            car_state, waypoints, last_nearest_waypoint_index, -3, 5
        )
        if nearest_waypoint_dist > search_threshold_squared:  # No more direct access to Settings
            nearest_waypoint_index, nearest_waypoint_dist = get_nearest_waypoint(car_state, waypoints)

    # Determine sector scaling
    sector_index = -1
    sector_scaling = 1.0
    if sectors is not None:
        for i in range(len(sectors)):
            start_idx = sectors[i, SECTOR_START_IDX]
            end_idx = sectors[i, SECTOR_END_IDX]
            if start_idx <= nearest_waypoint_index * decrease_resolution_factor < end_idx:
                sector_index = i
                sector_scaling = sectors[i, SECTOR_SCALING_IDX]
                break

    # Compute next waypoints efficiently
    next_waypoints_indices = (np.arange(look_ahead_steps + ignore_steps) + nearest_waypoint_index) % num_waypoints
    next_waypoints_including_ignored = waypoints[next_waypoints_indices]

    # Store only the relevant waypoints
    next_waypoints = next_waypoints_including_ignored[ignore_steps:]

    return nearest_waypoint_index, next_waypoints, sector_index, sector_scaling


# @njit(fastmath=True)
def get_waypoint_positions(waypoints):
    if waypoints is None: return None
    return np.array(waypoints)[:, 1:3]      
    
@njit(fastmath=True)
def get_relative_positions_jit(waypoints, car_state):
    # Compute relative positions using vectorized math
    waypoints_x_absolute = waypoints[:, WP_X_IDX]
    waypoints_y_absolute = waypoints[:, WP_Y_IDX]

    # Translation
    next_waypoints_x_after_translation = waypoints_x_absolute - car_state[POSE_X_IDX]
    next_waypoints_y_after_translation = waypoints_y_absolute - car_state[POSE_Y_IDX]

    # Rotation (vectorized transformation)
    next_waypoint_positions_relative = np.column_stack((
        next_waypoints_x_after_translation * car_state[POSE_THETA_COS_IDX] +
        next_waypoints_y_after_translation * car_state[POSE_THETA_SIN_IDX],

        next_waypoints_x_after_translation * -car_state[POSE_THETA_SIN_IDX] +
        next_waypoints_y_after_translation * car_state[POSE_THETA_COS_IDX]
    ))
    return next_waypoint_positions_relative


@njit(fastmath=True)
def get_nearest_waypoint(car_state, waypoints, last_nearest_waypoint_index=None, lower_search_limit=None, upper_search_limit=None):
    car_position = np.array([car_state[POSE_X_IDX], car_state[POSE_Y_IDX]])
    num_waypoints = len(waypoints)

    if last_nearest_waypoint_index is None or lower_search_limit is None or upper_search_limit is None:
        candidate_indices = np.arange(num_waypoints)
    else:
        start_idx = last_nearest_waypoint_index + lower_search_limit
        end_idx = last_nearest_waypoint_index + upper_search_limit
        candidate_indices = np.mod(np.arange(start_idx, end_idx + 1), num_waypoints)  # Wrap-around indexing

    best_index = candidate_indices[0]
    best_dist = np.sum((car_position - waypoints[best_index, WP_X_IDX:WP_Y_IDX + 1]) ** 2)

    for idx in candidate_indices:
        waypoint_position = waypoints[idx, WP_X_IDX:WP_Y_IDX + 1]
        dist = np.sum((car_position - waypoint_position) ** 2)
        if dist < best_dist:
            best_dist = dist
            best_index = idx

    return best_index, best_dist



@njit
def get_distance_to_raceline_jit(waypoints, nearest_waypoint_index, car_position):
    nearest_waypoint_position = waypoints[nearest_waypoint_index, WP_X_IDX:WP_Y_IDX+1]
    next_waypoint_position = waypoints[(nearest_waypoint_index + 1) % len(waypoints), WP_X_IDX:WP_Y_IDX+1]
    last_waypoint_position = waypoints[(nearest_waypoint_index - 1) % len(waypoints), WP_X_IDX:WP_Y_IDX+1]

    # Compute perpendicular distance to raceline using vectorized NumPy
    diff1 = nearest_waypoint_position - last_waypoint_position
    diff2 = next_waypoint_position - nearest_waypoint_position

    norm1 = np.linalg.norm(diff1)
    norm2 = np.linalg.norm(diff2)

    current_distance_to_last = np.abs(cross2d(diff1, last_waypoint_position - car_position)) / norm1
    current_distance_to_next = np.abs(cross2d(diff2, nearest_waypoint_position - car_position)) / norm2
    current_distance_to_raceline = np.minimum(current_distance_to_last, current_distance_to_next)
    
    return current_distance_to_last, current_distance_to_next, current_distance_to_raceline
@njit(fastmath=True)
def squared_distance(p1, p2):
    squared_distance = abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2
    return squared_distance

@njit(fastmath=True)
def check_if_obstacle_on_raceline(lidar_points, waypoints, threshold=0.25):
    """
    Optimized JIT + parallel function to check if any LiDAR point
    is within a threshold distance from any waypoint on the raceline.

    Args:
        lidar_points: (N, 2) NumPy array of LiDAR scan points (x, y).
        waypoints: (M, 2) NumPy array of waypoints representing the raceline.
        threshold: Squared distance threshold (0.5m^2 = 0.25).

    Returns:
        obstacle_on_raceline: True if any LiDAR point is within threshold distance.
        obstacle_position: [x, y] global position of the detected obstacle.
    """
    N = lidar_points.shape[0]
    M = waypoints.shape[0]

    obstacle_position = None  # Initialize obstacle position

    min_squared_distances = np.full(N, np.inf)  # Initialize min distances

    # Parallel loop over LiDAR points
    for i in prange(N):
        for j in range(M):
            dx = lidar_points[i, 0] - waypoints[j, 0]
            dy = lidar_points[i, 1] - waypoints[j, 1]
            squared_distance = dx * dx + dy * dy

            if squared_distance < min_squared_distances[i]:
                min_squared_distances[i] = squared_distance

        # Early exit for this LiDAR point (not possible in parallel, so checked at the end)
        if min_squared_distances[i] < threshold:
            obstacle_position = lidar_points[i]
            return True, obstacle_position  # If any point is within the threshold, return immediately

    return False, obstacle_position  # No obstacle detected within threshold


# Utility functions
def get_path_suffix(reverse_direction):
    return '_reverse' if reverse_direction else ''


def create_default_speed_scaling_file(speed_scaling_pth):
    print("No Speed scaling file defined. Creating new speed_scaling.csv with default values")
    with open(speed_scaling_pth, 'w') as f:
        f.write('#Start,Scaling\n')
        f.write('0,0.5\n')


def create_sectors(speed_scaling_csv, waypoints_len):
    sectors = []
    for i, csv_line in enumerate(speed_scaling_csv):
        start = int(csv_line[0])
        end = (int(waypoints_len) - 1) if (i == speed_scaling_csv.shape[0] - 1) else (int(speed_scaling_csv[i + 1, 0]) - 1)
        length = (end - start) + 1
        sector = [start, end, csv_line[1], length]
        sectors.append(sector)
    return np.array(sectors)


def generate_speed_scaling_array(sectors):
    speed_scaling_array = []

    for sector in sectors:
        length = int(sector[SECTOR_LENGTH_IDX])
        scaling_value = sector[SECTOR_SCALING_IDX]
        repeated_values = np.full(length, scaling_value)
        speed_scaling_array.append(repeated_values)

    speed_scaling_array = np.concatenate(speed_scaling_array)

    return speed_scaling_array


def get_speed_scaling_from_sectors(waypoints_len, map_path, map_name, settings):
    # TODO: Interpolate at edges
    # TODO: Drop error when not all sectors are defined
    path_reverse = get_path_suffix(settings.REVERSE_DIRECTION)

    speed_scaling_pth = os.path.join(map_path, f"{map_name}_speed_scaling{path_reverse}.csv")

    if not os.path.isfile(speed_scaling_pth):
        create_default_speed_scaling_file(speed_scaling_pth)

    speed_scaling_csv = pd.read_csv(speed_scaling_pth, comment='#', header=None).to_numpy()
    sectors = create_sectors(speed_scaling_csv, waypoints_len)

    speed_scaling_array = generate_speed_scaling_array(sectors)

    return speed_scaling_array


def get_speed_scaling(waypoints_len, map_path, map_name, settings):
    speed_scaling = settings.GLOBAL_WAYPOINT_VEL_FACTOR
    if settings.APPLY_SPEED_SCALING_FROM_CSV:
        speed_scaling *= get_speed_scaling_from_sectors(waypoints_len, map_path, map_name, settings)
    speed_scaling = np.clip(speed_scaling, 0, settings.GLOBAL_SPEED_LIMIT)
    return speed_scaling


