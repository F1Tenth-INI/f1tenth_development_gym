from utilities.Settings import Settings
from utilities.state_utilities import *

import time
import threading

import os.path
import numpy as np
import pandas as pd

'''
HOW TO USE:

1. Generate/Get a Waypoints CSV File (https://github.com/TUMFTM/global_racetrajectory_optimization )
2. Set the waypoint_payth in the map config file (fe. config_Custom.yaml) to the generated file (without .csv)
3. Set Waypoint parameters in config.yml
4. Use inside planner class like this:

# Import 
from utilities.waypoint_utils import WaypointUtils

# Initialize
waypoint_utils = WaypointUtils()

# Update at every step for the next_waypoints with the current car's position
car_position = [0., 0.]
waypoint_utils.update_next_waypoints(car_state)

# Access next waypoint's positions list([x,y]):
waypoints_positions = waypoint_utils.next_waypoint_positions

# Or Access next full waypoints list([dist, x, y, abs_angle, rel_angle, v_x, acc_x]):
waypoints = waypoint_utils.next_waypoints

'''


# Indices of waypoint
WP_S_IDX = 0 # Distance since start
WP_X_IDX = 1 # Position x
WP_Y_IDX = 2 # Position y
WP_PSI_IDX = 3 # Absolute angle of vector connecting to next wp
WP_KAPPA_IDX = 4 # Relative angle
WP_VX_IDX = 5 # Suggested velocity 
WP_A_X_IDX = 6 # Suggested acceleration
WP_GLOBID_IDX = 7


# Indices for sectors
SECTOR_START_IDX = 0
SECTOR_END_IDX = 1
SECTOR_SCALING_IDX = 2
SECTOR_LENGTH_IDX = 3


def squared_distance(p1, p2):
    squared_distance = abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2
    return squared_distance

class WaypointUtils:
    
    def __init__(self,waypoint_file_name=Settings.MAP_NAME+"_wp", map_path= Settings.MAP_PATH , map_name=Settings.MAP_NAME, alternative_waypoints=False):
        
        self.map_path = map_path
        self.map_name = map_name

        self.alternative_waypoints = alternative_waypoints
        if alternative_waypoints:
            self.waypoint_file_name = waypoint_file_name + "_alternative"
        else:
            self.waypoint_file_name = waypoint_file_name
        
        self.interpolation_steps = Settings.INTERPOLATION_STEPS
        self.decrease_resolution_factor = Settings.DECREASE_RESOLUTION_FACTOR

        self.look_ahead_steps = self.interpolation_steps * Settings.LOOK_AHEAD_STEPS
        self.ignore_steps = Settings.IGNORE_STEPS

        self.car_state = None

        # sectors
        self.sector_index = 0
        self.sector_scaling = 0
        self.sectors = None
        
        # Variables for automatic sector tuning
        self.sector_error_index = 0
        self.sector_number_of_states = 1
        self.sector_error = 0
        
        # Waypoints generated by https://github.com/TUMFTM/global_racetrajectory_optimization
        self.original_waypoints = self.load_waypoints()
        self.sectors = self.load_sectors()

        # print(self.sectors)
        # exit()
        
        self.current_distance_to_raceline = 0

        self.global_limit = None
        self.waypoints = None
        self.waypoint_positions = None

        self.preprocess_waypoints()

        self.nearest_waypoint_index = None
        
        # next waypoints including the ones ignored by index offset: Relevant for looking for next (cache for looking for next one)
        self.current_waypoint_cache = np.zeros((self.look_ahead_steps, 8), dtype=np.float32)

         # next waypoints considering ignored waypoints index offset
        self.next_waypoints = np.zeros((self.look_ahead_steps, 8), dtype=np.float32)
        self.next_waypoint_positions = np.zeros((self.look_ahead_steps,2), dtype=np.float32)
        self.next_waypoint_positions_relative = np.zeros((self.look_ahead_steps,2), dtype=np.float32)



        if(self.waypoints is None):
            self.current_waypoint_cache = np.array([])
            self.next_waypoints = np.array([])
            self.next_waypoint_positions = np.array([])

        # Start the thread that reloads waypoints every 5 seconds
        self.start_reload_waypoints_thread()


    def start_reload_waypoints_thread(self):
        def reload_loop():
            while True:
                self.reload_waypoints()
                time.sleep(5)
        thread = threading.Thread(target=reload_loop)
        thread.daemon = True  # Daemonize thread to exit when main program exits
        thread.start()


    def update_next_waypoints(self, car_state):

        waypoints = self.waypoints
        nearest_waypoint_index = self.nearest_waypoint_index
        current_waypoint_cache = self.current_waypoint_cache
        sectors = self.sectors
        next_waypoints = self.next_waypoints
        next_waypoint_positions_relative = self.next_waypoint_positions_relative

        if waypoints is None: return
        self.car_state = car_state
        car_position = [car_state[POSE_X_IDX], car_state[POSE_Y_IDX]]

        if nearest_waypoint_index is None or Settings.GLOBAL_WAYPOINTS_SEARCH_THRESHOLD is None:
            # Run initial search of starting waypoint (all waypoints)
            nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position, waypoints)
        else:
            # only look for next waypoint in the current waypoint cache
            dist_max = Settings.GLOBAL_WAYPOINTS_SEARCH_THRESHOLD
            cache_offset = WaypointUtils.get_nearest_waypoint_index(car_position, current_waypoint_cache)
            nearest_waypoint_index_glob = (nearest_waypoint_index + cache_offset) % len(waypoints)
            dist_current_waypoint = squared_distance(current_waypoint_cache[cache_offset, 1:3], car_position)
            if dist_current_waypoint > dist_max**2: # if the current waypoint is too far away, fallback to all waypoints
                nearest_waypoint_index = WaypointUtils.get_nearest_waypoint_index(car_position, waypoints)
            else:
                #only search in cache
                nearest_waypoint_index = nearest_waypoint_index_glob

        # Get distance from car position to raceline (the vector connecting the waypoints, either last to current or curent to next)
        nearest_waypoint_position = waypoints[nearest_waypoint_index][WP_X_IDX:WP_Y_IDX+1]
        next_waypoint_position = waypoints[(nearest_waypoint_index + 1) % len(waypoints)][WP_X_IDX:WP_Y_IDX+1]
        last_waypoint_position = waypoints[(nearest_waypoint_index - 1) % len(waypoints)][WP_X_IDX:WP_Y_IDX+1]
        
        # Calculate the distance to the raceline
        self.current_distance_to_last = np.linalg.norm(np.cross(nearest_waypoint_position - last_waypoint_position, last_waypoint_position - car_position)) / np.linalg.norm(nearest_waypoint_position - last_waypoint_position)
        self.current_distance_to_next = np.linalg.norm(np.cross(next_waypoint_position - nearest_waypoint_position, nearest_waypoint_position - car_position)) / np.linalg.norm(next_waypoint_position - nearest_waypoint_position)   
        self.current_distance_to_raceline = min(self.current_distance_to_last, self.current_distance_to_next)
        
        # Find out in which sector the car is
        sector_index = None
        sector_scaling = None
        if sectors is not None:
            for i in range(sectors.shape[0]):
                if sectors[i, SECTOR_START_IDX] <= nearest_waypoint_index * self.decrease_resolution_factor < sectors[i, SECTOR_END_IDX]:
                    sector_index = i
                    sector_scaling = self.sectors[i, SECTOR_SCALING_IDX]
                    break
        
        if(Settings.AUTOMATIC_SECTOR_TUNING):
            self.automatic_sector_tuning(nearest_waypoint_index, car_state)
        
        next_waypoints_including_ignored = []
        next_waypoints_indices_including_ignored = []
        for j in range(self.look_ahead_steps + self.ignore_steps):
            next_waypoint_idx = (nearest_waypoint_index + j) % len(waypoints)
            next_waypoint = waypoints[next_waypoint_idx]
            next_waypoints_indices_including_ignored.append(next_waypoint_idx)
            next_waypoints_including_ignored.append(next_waypoint)
        next_waypoints_including_ignored = np.array(next_waypoints_including_ignored)
        next_waypoints_indices_including_ignored = np.array(next_waypoints_indices_including_ignored)

        next_waypoints[...] = next_waypoints_including_ignored[self.ignore_steps:]
        current_waypoint_cache = next_waypoints_including_ignored
        
        next_waypoint_positions = WaypointUtils.get_waypoint_positions(next_waypoints)
        next_waypoint_positions_relative[...] = WaypointUtils.get_relative_positions(next_waypoints, car_state)
        nearest_waypoint_index = nearest_waypoint_index

        if sector_index is not None:
            self.sector_index = sector_index
        if sector_scaling is not None:
            self.sector_scaling = sector_scaling
        self.current_waypoint_cache = current_waypoint_cache
        self.next_waypoint_positions = next_waypoint_positions
        self.next_waypoint_positions_relative = next_waypoint_positions_relative
        self.nearest_waypoint_index = nearest_waypoint_index

    def automatic_sector_tuning(self, nearest_waypoint_index, car_state):
        if self.sector_error_index == self.sector_index:
            nearest_waypoint_position = self.waypoints[nearest_waypoint_index][WP_X_IDX:WP_Y_IDX+1]
            car_position = [car_state[POSE_X_IDX], car_state[POSE_Y_IDX]]
            dist = np.linalg.norm(nearest_waypoint_position - car_position)
            self.sector_error += dist
            self.sector_number_of_states +=1
        else: # new sector
            # Normalize sector error
            self.sector_error = self.sector_error / self.sector_number_of_states
            print("sector error", self.sector_error)
            print("New sector", self.sector_index)
            
        
            sector = self.sectors[self.sector_error_index]
            error_shifted = self.sector_error - 0.20
            sector[SECTOR_SCALING_IDX] -= 1.5*error_shifted
            print("Adusting sector scaling by ", 1.5 * -error_shifted)
            
            
            # Read the file into a list of lines
            with open(self.speed_scaling_pth, 'r') as file:
                lines = file.readlines()

            # Replace the ith line
            csv_line = str(sector[SECTOR_START_IDX]) + ","+ str(sector[SECTOR_SCALING_IDX]) + "\n"
            lines[self.sector_error_index + 1] = csv_line # +1 because of header

            # Write the list of lines back to the file
            with open(self.speed_scaling_pth, 'w') as file:
                file.writelines(lines)
            # Load the CSV file
            # df = pd.read_csv(self.speed_scaling_pth, header=1)
            # df.loc[self.sector_index -1] = csv_line
            # df.to_csv(self.speed_scaling_pth, index=False)

            
            self.sector_error = 0
            self.sector_number_of_states = 0
            self.sector_error_index = self.sector_index
            
            self.reload_waypoints()

    def preprocess_waypoints(self):

        original_waypoints = self.original_waypoints

        # Full waypoints [traveled_dist, x, y, abs_angle, rel_angle, vel_x, acc_x]
        waypoints, self.global_limit = self.correct_velocity(original_waypoints)
        waypoints = WaypointUtils.get_interpolated_waypoints(waypoints, self.interpolation_steps)  # increased resolution
        waypoints = WaypointUtils.get_decreased_resolution_wps(waypoints, self.decrease_resolution_factor)  # decreased resolution
        waypoints = WaypointUtils.remove_duplicates(waypoints)

        # Waypoint positions [x, y]
        waypoint_positions = WaypointUtils.get_waypoint_positions(waypoints)

        self.waypoints = waypoints
        self.waypoint_positions = waypoint_positions

        # This last line seems to be not used anywhere, for a long time
        # self.trajectory_vectors, self.trajectory_norms, self.directions = self.get_vectors_between_waypoint_positions()

    def reload_waypoints(self):

        waypoint_file_name = self.waypoint_file_name
        self.original_waypoints = self.load_waypoints(waypoint_file_name)
        self.sectors = self.load_sectors()
        self.preprocess_waypoints()
        
    def load_waypoints(self, waypoint_file_name=None):

        if waypoint_file_name is None:
            waypoint_file_name = self.waypoint_file_name

        path = os.path.join(self.map_path, waypoint_file_name)

        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'

        file_path = path + '.csv'
        try: # Check if waypoint file exists
            assert os.path.isfile(file_path), "Waypoint file (" + path+  ") does not exist"
        except AssertionError:
            print("There are no waypoints at "+file_path)
            print("Continuting without waypoinnts")
            return None
        
        waypoints = pd.read_csv(file_path, comment='#')
        waypoints.loc[:, "idx_global"] = np.arange(waypoints.shape[0])
        waypoints = waypoints.to_numpy()
        # Original Psi is the normal angle but we want the translational one
        waypoints[:, WP_PSI_IDX] += 0.5 * np.pi
        return np.array(waypoints)
    
    def load_sectors(self):
        path = os.path.join(self.map_path, self.map_name)
        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'

        if self.alternative_waypoints:
            speed_scaling_pth = path + '_speed_scaling_alternative.csv'
        else:
            speed_scaling_pth = path + '_speed_scaling.csv'
        
        if not os.path.exists(speed_scaling_pth):
            create_default_speed_scaling_file(speed_scaling_pth)


        sector_csv = pd.read_csv(speed_scaling_pth, comment='#', header=None).to_numpy()
        result = []
        for i in range(len(sector_csv)):
            start_idx = int(sector_csv[i][0])
            scaling = sector_csv[i][1]
            if i < len(sector_csv) - 1:
                end_idx = int(sector_csv[i + 1][0]) - 1
            else:
                end_idx = len(self.original_waypoints)-1  # Use the index of the last waypoint
            length_of_sector = end_idx - start_idx
            result.append([start_idx, end_idx, scaling, length_of_sector])
        return np.array(result)


    def add_sector(self):
        current_sector = self.sectors[self.sector_index]
        new_sector = np.zeros(4)
        new_sector[SECTOR_START_IDX] = self.next_waypoints[0, WP_GLOBID_IDX] * Settings.DECREASE_RESOLUTION_FACTOR
        new_sector[SECTOR_SCALING_IDX] = self.sector_scaling
        new_sector[SECTOR_END_IDX] = current_sector[SECTOR_END_IDX]

        current_sector[SECTOR_END_IDX] = new_sector[SECTOR_START_IDX] - 1

        self.sectors[self.sector_index] = current_sector
        self.sectors = np.insert(self.sectors, self.sector_index + 1, new_sector, axis=0)

        self.sectors = self.sectors[self.sectors[:, SECTOR_START_IDX].argsort()]
        self.save_sector_file()


    def delete_current_sector(self):

        if len(self.sectors) > 1:
            # Remove the current sector
            self.sectors = np.delete(self.sectors, self.sector_index, axis=0)
            # Adjust the sector index if necessary
            if self.sector_index >= len(self.sectors):
                self.sector_index = len(self.sectors) - 1
        self.save_sector_file()

    def change_sector(self, sector_index, new_scaling):
        self.sectors[sector_index][SECTOR_SCALING_IDX] = new_scaling
        self.save_sector_file()

    def save_sector_file(self):
        path = os.path.join(self.map_path, self.map_name)
        if Settings.REVERSE_DIRECTION:
            path = path + '_reverse'
        speed_scaling_pth = path + '_speed_scaling.csv'
        with open(speed_scaling_pth, 'w') as f:
            f.write('#Start,Scaling\n')
            for i in range(len(self.sectors)):
                f.write(str(self.sectors[i][SECTOR_START_IDX]) + ',' + str(self.sectors[i][SECTOR_SCALING_IDX]) + '\n')

        self.reload_waypoints()

    @staticmethod
    def get_interpolated_waypoints(waypoints, interpolation_steps):
        if waypoints is None: return None
        assert(interpolation_steps >= 1)
        waypoints_interpolated = []
        
        for j in range(len(waypoints) - 1):
            for i in range(interpolation_steps):
                interpolated_waypoint = waypoints[j] + (float(i)/interpolation_steps)*(waypoints[j+1]-waypoints[j])
                waypoints_interpolated.append(interpolated_waypoint)
        waypoints_interpolated.append(waypoints[-1])
        return np.array(waypoints_interpolated)
    @staticmethod
    def get_decreased_resolution_wps(waypoints, decrease_resolution_factor):
        if waypoints is None: return None
        return np.array(waypoints[::decrease_resolution_factor])
    
    @staticmethod
    def get_nearest_waypoint_index(car_position, waypoints):

        min_dist = 10000
        min_dist_index = 0

        waypoint_positions = WaypointUtils.get_waypoint_positions(waypoints)
        for i in range(len(waypoint_positions)):
            dist = squared_distance(waypoint_positions[i], car_position)
            if (dist) < min_dist:
                min_dist = dist
                min_dist_index = i

        return min_dist_index
    
    @staticmethod
    def get_waypoint_positions(waypoints):
        if waypoints is None: return None
        return np.array(waypoints)[:, 1:3]
    
    def get_vectors_between_waypoint_positions(self):
        if self.waypoints is None: return None, None, None
        waypoint_positions = self.get_waypoint_positions(self.waypoints)
        vectors = []
        norms = []
        directions = []
        for i in range(len(waypoint_positions)-1):
            vector = waypoint_positions[i + 1] - waypoint_positions[i]
            vectors.append(vector)
            norm = np.linalg.norm(vector)
            norms.append(norm)
            directions.append(vector/norm)
        return vectors, norms, directions
    
    @staticmethod
    def remove_duplicates(waypoints):
        # Remove duplicate waypoints ( with same positions )
        if waypoints is None: return None
        
        wawypoint_positions = waypoints[:,1:3]
        unique_positions, unique_indices = np.unique(wawypoint_positions, axis=0, return_index=True)
        unique_indices = np.sort(unique_indices)
    
        unique_waypoints = waypoints[unique_indices, :]
        return np.array(unique_waypoints)
    
    @staticmethod
    def get_relative_positions(waypoints, car_state):
        waypoints_x_absolute = waypoints[:,WP_X_IDX]
        waypoints_y_absolute = waypoints[:,WP_Y_IDX]
     
        ### Coordinate transformation to describe waypoint position relative to car position, x-axis points through windshield, y-axis to the left of the driver            # Translation:
        # translation by x and y coordinate of car
        next_waypoints_x_after_translation = waypoints_x_absolute - car_state[POSE_X_IDX]
        next_waypoints_y_after_translation = waypoints_y_absolute - car_state[POSE_Y_IDX]

        # Rotation (counterclockwise):
        next_waypoints_x_relative = np.round( next_waypoints_x_after_translation * car_state[POSE_THETA_COS_IDX] + next_waypoints_y_after_translation *  car_state[POSE_THETA_SIN_IDX], 4)
        next_waypoints_y_relative = np.round( next_waypoints_x_after_translation * - car_state[POSE_THETA_SIN_IDX] + next_waypoints_y_after_translation *  car_state[POSE_THETA_COS_IDX], 4)

        next_waypoint_positions_relative = np.column_stack((next_waypoints_x_relative, next_waypoints_y_relative))
        return next_waypoint_positions_relative
    
    def correct_velocity(self, waypoints):
        settings = Settings        
        speed_scaling = get_speed_scaling(waypoints.shape[0], self.map_path, self.map_name, settings)
        waypoints[:, WP_VX_IDX] *= speed_scaling
        return waypoints, Settings.GLOBAL_SPEED_LIMIT


# Utility functions
def get_path_suffix(reverse_direction):
    return '_reverse' if reverse_direction else ''


def create_default_speed_scaling_file(speed_scaling_pth):
    print("No Speed scaling file defined. Creating new speed_scaling.csv with default values")
    with open(speed_scaling_pth, 'w') as f:
        f.write('#Start,Scaling\n')
        f.write('0,0.5\n')


def create_sectors(speed_scaling_csv, waypoints_len):
    sectors = []
    for i, csv_line in enumerate(speed_scaling_csv):
        start = int(csv_line[0])
        end = (int(waypoints_len) - 1) if (i == speed_scaling_csv.shape[0] - 1) else (int(speed_scaling_csv[i + 1, 0]) - 1)
        length = (end - start) + 1
        sector = [start, end, csv_line[1], length]
        sectors.append(sector)
    return np.array(sectors)


def generate_speed_scaling_array(sectors):
    speed_scaling_array = []

    for sector in sectors:
        length = int(sector[SECTOR_LENGTH_IDX])
        scaling_value = sector[SECTOR_SCALING_IDX]
        repeated_values = np.full(length, scaling_value)
        speed_scaling_array.append(repeated_values)

    speed_scaling_array = np.concatenate(speed_scaling_array)

    return speed_scaling_array


def get_speed_scaling_from_sectors(waypoints_len, map_path, map_name, settings):
    # TODO: Interpolate at edges
    # TODO: Drop error when not all sectors are defined
    path_reverse = get_path_suffix(settings.REVERSE_DIRECTION)

    speed_scaling_pth = os.path.join(map_path, f"{map_name}_speed_scaling{path_reverse}.csv")

    if not os.path.isfile(speed_scaling_pth):
        create_default_speed_scaling_file(speed_scaling_pth)

    speed_scaling_csv = pd.read_csv(speed_scaling_pth, comment='#', header=None).to_numpy()
    sectors = create_sectors(speed_scaling_csv, waypoints_len)

    speed_scaling_array = generate_speed_scaling_array(sectors)

    return speed_scaling_array


def get_speed_scaling(waypoints_len, map_path, map_name, settings):
    speed_scaling = settings.GLOBAL_WAYPOINT_VEL_FACTOR
    if settings.APPLY_SPEED_SCALING_FROM_CSV:
        speed_scaling *= get_speed_scaling_from_sectors(waypoints_len, map_path, map_name, settings)
    speed_scaling = np.clip(speed_scaling, 0, settings.GLOBAL_SPEED_LIMIT)
    return speed_scaling


