library: 'TF'  # TF or Pytorch
modeling:
  # NET_NAME: 'Dense-64H1-128H2-64H3' # Dense/LSTM/Simple-RNN/GRU
  # NET_NAME: 'Dense-10IN-64H1-128H2-64H3-8OUT-1'
  NET_NAME: 'LSTM-16H1-32H2-16H3'
  # NET_NAME: 'LSTM-10IN-32H1-32H2-8OUT-0'
  # NET_NAME: 'GRU-32H1-32H2-32H3'
  # NET_NAME: 'Custom-ODE_module-KSModelMu'
  # NET_NAME: 'Custom-tiv_module-TIVModelDNNRealCar'
  # NET_NAME: 'Custom-7IN-tiv_module-TIVModelDNN-7OUT-1'
  # NET_NAME: 'Custom-tiv_module-TIVModelLSTM'
  # NET_NAME: 'Custom-ODE_NN_module-ODE_DNN'
paths:
  # PATH HAS TO END WITH A SOLIDUS ("/") CHARACTER
  PATH_TO_EXPERIMENT_FOLDERS: './SI_Toolkit_ASF/Experiments/'  # Path where the experiments data is stored
  path_to_experiment: 'Experiment-2_less_states/'
  DATA_FOLDER: 'Recordings_preprocessed'


training_default:
  ##########  Simulation ############
  #### For training closed loop dynamics model:
  # state_inputs: [ 'angular_vel_z', 'linear_vel_x', 'pose_x', 'pose_y', 'pose_theta_cos', 'pose_theta_sin', 'slip_angle', 'steering_angle' ]
  # control_inputs: [ 'translational_control', 'angular_control' ]
  # outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta_cos', 'D_pose_theta_sin', 'D_pose_x', 'D_pose_y',  'D_slip_angle','D_steering_angle' ]
  # translation_invariant_variables: []
  # setpoint_inputs: []

  #### For training a translation invariant closed loop dynamics model:
  # state_inputs: ['angular_vel_z', 'linear_vel_x', 'pose_theta', 'slip_angle', 'steering_angle' ]
  # control_inputs: [ 'translational_control', 'angular_control' ]
  # outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta', 'D_pose_x', 'D_pose_y', 'D_slip_angle','D_steering_angle' ]
  # translation_invariant_variables: []
  # setpoint_inputs: []

  #### For adaptive control with custom module
  # state_inputs: ['angular_vel_z', 'linear_vel_x', 'pose_theta', 'pose_theta_cos', 'pose_theta_sin', 'pose_x', 'pose_y', 'slip_angle', 'steering_angle' ]
  # control_inputs: [ 'translational_control', 'angular_control' ]
  # # outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta', 'D_pose_theta_cos', 'D_pose_theta_sin', 'D_pose_x', 'D_pose_y', 'D_slip_angle','D_steering_angle' ]
  # outputs: [ 'angular_vel_z', 'linear_vel_x', 'pose_theta', 'pose_theta_cos', 'pose_theta_sin', 'pose_x', 'pose_y', 'slip_angle','steering_angle']
  # translation_invariant_variables: []
  # setpoint_inputs: [] 
  
  # For training the mixed ODE-DNN model  
  # state_inputs: ['angular_vel_z', 'linear_vel_x', 'pose_theta', 'pose_theta_cos', 'pose_theta_sin', 'pose_x', 'pose_y', 'slip_angle', 'steering_angle' ]
  # control_inputs: [ 'translational_control', 'angular_control' ]
  # outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta_cos', 'D_pose_theta_sin', 'D_pose_x', 'D_pose_y', 'D_slip_angle','D_steering_angle' ]
  # translation_invariant_variables: []
  # setpoint_inputs: [] 

  ##########  Real Car ############
  ### For training closed loop dynamics model:
  # state_inputs: [ 'angular_vel_z', 'linear_vel_x', 'pose_x', 'pose_y', 'pose_theta_cos', 'pose_theta_sin', 'steering_angle' ]
  # control_inputs: [ 'translational_control', 'angular_control' ]
  # outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta_cos', 'D_pose_theta_sin', 'D_pose_x', 'D_pose_y', 'D_steering_angle' ]
  # translation_invariant_variables: []
  # setpoint_inputs: []

  #### For training a translation invariant closed loop dynamics model:
  # state_inputs: ['angular_vel_z', 'linear_vel_x', 'pose_theta', 'steering_angle' ]
  # control_inputs: [ 'translational_control', 'angular_control' ]
  # outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta', 'D_pose_x', 'D_pose_y', 'D_steering_angle' ]
  # translation_invariant_variables: []
  # setpoint_inputs: []
  

  ############### Tryout ##############
  ### For training closed loop dynamics model:
  state_inputs: [ 'angular_vel_z', 'linear_vel_x', 'pose_x', 'pose_y', 'pose_theta_cos', 'pose_theta_sin', 'steering_angle' ]
  control_inputs: [ 'translational_control', 'angular_control' ]
  outputs: [ 'D_angular_vel_z', 'D_linear_vel_x', 'D_pose_theta_cos', 'D_pose_theta_sin', 'D_pose_x', 'D_pose_y', 'D_steering_angle' ]
  translation_invariant_variables: []
  setpoint_inputs: []

  
  
  EPOCHS: 20
  BATCH_SIZE: 8
  SEED: 1873
  LR: 1.0e-3
  WASH_OUT_LEN: 20
  POST_WASH_OUT_LEN: 1
  ON_FLY_DATA_GENERATION: False
  NORMALIZE: True
  SHIFT_LABELS: 1  # for k, as a label to row i is taken row i+k
  USE_NNI: False  # Decide if you want to use NNI package
  CONSTRUCT_NETWORK: 'with cells'  # Matters only for Pytorch

  REDUCE_LR_ON_PLATEAU:
    ACTIVATED: True
    FACTOR: 0.316  # Factor to reduce learning rate by (0.316 = sqrt(0.1))
    PATIENCE: 1
    MIN_LR: 1.0e-5
    MIN_DELTA: 0.00


  ### Lidar Data: from 0 to 1080 on 270 Degrees (4 ranges per degree). Example; scan exactly 180 Degrees by setting lower_bound=180 and upper_bound=900.
  # Depending on number of Lidar points listed in state input, an even distribution of input scans between the two bounds is selected and fed to the network.
  #ToDo instead of listing all Lidar Points, one just writes how many and the state input vector is generated automatically
  upper_bound: 880
  lower_bound: 200
